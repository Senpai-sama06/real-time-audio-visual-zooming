import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from scipy.signal import stft, istft
from scipy.io import wavfile
import os
import sys

# Import system components
# Ensure these files (config.py, classifier.py, actuator.py) are in the same folder
from config import SystemConfig
from classifier import SpatioSpectralClassifier
from actuator import SpatioSpectralActuator

# ==============================================================================
# 1. ROBUST DATA LOADER
# ==============================================================================
def load_world_files(base_path="sample"):
    """
    Loads the 4 aligned files generated by world.py.
    CRITICAL FIX: Normalizes int16/int32 audio to [-1.0, 1.0] float range.
    """
    files = {
        "mix": os.path.join(base_path, "mixture.wav"),
        "tgt": os.path.join(base_path, "target.wav"),
        "int": os.path.join(base_path, "interference.wav"),
        "noi": os.path.join(base_path, "noise.wav")
    }
    
    data = {}
    fs = 16000
    
    for key, path in files.items():
        if not os.path.exists(path):
            print(f"Error: Missing {path}. Run 'python world.py' first!")
            sys.exit(1)
            
        fs_in, audio = wavfile.read(path)
        
        # --- NORMALIZATION FIX ---
        if audio.dtype == np.int16:
            audio = audio.astype(np.float32) / 32768.0
        elif audio.dtype == np.int32:
            audio = audio.astype(np.float32) / 2147483648.0
        else:
            audio = audio.astype(np.float32)
            
        data[key] = audio
        fs = fs_in
        
    return fs, data

def get_oracle_labels(P_tgt, P_int, P_noi):
    """
    Determines 'Ground Truth' states based on which source is dominant 
    in each Time-Frequency bin.
    """
    labels = np.zeros_like(P_tgt, dtype=int)
    
    # Energy Dominance Logic (0dB threshold)
    # If Target Power > Interference + Noise -> Label 1 (Target)
    thresh = 1.0 
    
    mask_tgt = (P_tgt > (P_int + P_noi) * thresh)
    mask_int = (P_int > (P_tgt + P_noi) * thresh)
    
    # Default: H6 (Diffuse/Background)
    labels[:, :] = 6 
    
    # Overwrite with specific dominance
    labels[mask_int] = 5 # H5: Jammer
    labels[mask_tgt] = 1 # H1: Target
    
    return labels

# ==============================================================================
# 2. DIAGNOSTIC ACTUATOR (EXPOSES WEIGHTS)
# ==============================================================================
class DiagnosticActuator(SpatioSpectralActuator):
    """
    Subclass that allows us to peek at the calculated weights 'w'
    so we can run the Shadow Pass (apply weights to clean references).
    """
    def get_weights(self, Y_frame, R_nn, state):
        weights = np.zeros((self.n_bins, 2), dtype=complex)
        
        for f in range(self.n_bins):
            s = state[f]
            
            # --- PATH A: SPECTRAL / FALLBACK ---
            if s in [0, 3, 7]: 
                # Ideally this is a Wiener gain on Ch0, but for diagnostics
                # we approximate as Identity (Pass-through) to see the error.
                weights[f, 0] = 1.0 
                
            # --- PATH B: SPATIAL BEAMFORMING ---
            else:
                # 1. Select Parameters based on State
                if s in [2, 5]: # Jammer Detected
                    mu = 0.01
                    Phi = R_nn[f]
                elif s in [4, 6]: # Diffuse/Reverb
                    mu = 1.0
                    Phi = self.Phi_diffuse[f] * np.real(R_nn[f,0,0])
                else: # Clean Target (H1)
                    mu = 10.0 # High distortion penalty
                    Phi = np.eye(2) * 1e-6
                
                # 2. Solve Beamformer Equation: w = inv(Phi + mu*I) * d
                d = np.array([1.0, self.d_vec[f]], dtype=complex)
                Phi_reg = Phi + np.eye(2) * self.cfg.diagonal_load
                
                try:
                    # Solve linear system instead of explicit inverse for stability
                    x = np.linalg.solve(Phi_reg, d)
                    # MVDR Normalization
                    denom = np.vdot(d, x).real + 1e-12
                    w = x / denom
                    
                    # Post-Gating: If we are SURE it's a Jammer (H5), suppress it further
                    if s in [5, 6]: 
                        w *= 0.1 # -20dB suppression
                        
                    weights[f] = w
                except np.linalg.LinAlgError:
                    weights[f] = np.array([0.5, 0.5]) # Fallback
                    
        return weights

# ==============================================================================
# 3. METRIC TRACKER
# ==============================================================================
class MetricTracker:
    def __init__(self, name):
        self.name = name
        self.p_tgt_in = 0.0
        self.p_int_in = 0.0
        self.p_tgt_out = 0.0
        self.p_int_out = 0.0
        
    def update(self, w, Y_tgt, Y_int):
        """
        SHADOW PASS: Applies the calculated weights 'w' to the 
        ISOLATED clean components to measure exact physics.
        """
        # Beamforming: output = w^H * y
        # We assume w is [Bins, 2], Y is [Bins, 2]
        S_tgt = np.sum(w.conj() * Y_tgt, axis=1)
        S_int = np.sum(w.conj() * Y_int, axis=1)
        
        # Accumulate Scalar Power
        self.p_tgt_in += np.sum(np.abs(Y_tgt[:,0])**2)
        self.p_int_in += np.sum(np.abs(Y_int[:,0])**2)
        
        self.p_tgt_out += np.sum(np.abs(S_tgt)**2)
        self.p_int_out += np.sum(np.abs(S_int)**2)
        
    def report(self):
        # Avoid Log(0)
        eps = 1e-9
        
        # Target Preservation (Ideal: 0 dB)
        preservation = 10 * np.log10(self.p_tgt_out / (self.p_tgt_in + eps))
        
        # Jammer Suppression (Ideal: -Inf dB)
        suppression = 10 * np.log10(self.p_int_out / (self.p_int_in + eps))
        
        # SINR
        sinr_in = 10 * np.log10(self.p_tgt_in / (self.p_int_in + eps))
        sinr_out = 10 * np.log10(self.p_tgt_out / (self.p_int_out + eps))
        
        return preservation, suppression, sinr_in, sinr_out

# ==============================================================================
# 4. MAIN EXECUTION LOOP
# ==============================================================================
if __name__ == "__main__":
    
    # --- 1. SETUP & PHYSICS ALIGNMENT ---
    # CRITICAL: We explicitly set these to match world.py 
    # to prevent config file defaults (0.05m / 0.0 rad) from breaking physics.
    # Dist = 0.08m (Simulation Reality)
    # Angle = 1.5708 rad (90 degrees / Broadside)
    cfg = SystemConfig(mic_dist=0.08, target_angle=1.5708)
    
    print(f"Diagnostics Configured for: Angle={np.rad2deg(cfg.target_angle):.1f} deg | Dist={cfg.mic_dist} m")
    
    print("Loading Data...")
    fs, audio = load_world_files()
    n_fft = cfg.n_fft
    
    # Pre-compute STFTs for all components
    def get_stft(x): 
        _, _, Zxx = stft(x[:,0], fs=fs, nperseg=n_fft)
        _, _, Zyy = stft(x[:,1], fs=fs, nperseg=n_fft)
        return np.stack([Zxx, Zyy], axis=-1)

    Y_mix = get_stft(audio['mix'])
    Y_tgt = get_stft(audio['tgt'])
    Y_int = get_stft(audio['int'])
    
    # Oracle Noise Reference (Perfect knowledge of Jammer for Oracle Upper Bound)
    Y_oracle_noise = get_stft(audio['int'] + audio['noi']) 
    
    # Calculate Power Maps for Oracle Labeling
    P_tgt = np.abs(Y_tgt[:,:,0])**2 + np.abs(Y_tgt[:,:,1])**2
    P_int = np.abs(Y_int[:,:,0])**2 + np.abs(Y_int[:,:,1])**2
    
    # --- PHASE 1: BRAIN (ESTIMATOR) ---
    print("Running Classification...")
    
    # CRITICAL FIX: Pass the angle explicitly to the classifier!
    classifier = SpatioSpectralClassifier(target_angle_rad=cfg.target_angle)
    
    # Generate Truth
    oracle_map = get_oracle_labels(P_tgt, P_int, np.zeros_like(P_tgt))
    
    # Generate Estimate
    est_map = np.zeros_like(oracle_map)
    for i in range(Y_mix.shape[1]):
        est_map[:, i] = classifier.process_frame(Y_mix[:, i, :])
        
    # --- PHASE 2: MUSCLE (ACTUATOR) ---
    print("Running Actuation (Oracle vs Real)...")
    actuator = DiagnosticActuator(cfg)
    
    m_oracle = MetricTracker("Oracle")
    m_real = MetricTracker("Real System")
    
    # Output STFT Buffers
    S_oracle = np.zeros(Y_mix.shape[0:2], dtype=complex)
    S_real = np.zeros(Y_mix.shape[0:2], dtype=complex)
    
    for i in range(Y_mix.shape[1]):
        # Current Frames
        y_m = Y_mix[:, i, :]
        y_t = Y_tgt[:, i, :]
        y_i = Y_int[:, i, :]
        y_on = Y_oracle_noise[:, i, :] 
        
        # --- A. ORACLE PATH (Theoretical Max) ---
        # 1. Perfect Covariance (Instantaneous from Jammer)
        R_oracle = y_on[:, :, np.newaxis] @ y_on[:, :, np.newaxis].conj().transpose(0, 2, 1)
        # 2. Perfect Decisions
        dec_oracle = oracle_map[:, i]
        # 3. Compute Weights & Apply
        w_o = actuator.get_weights(y_m, R_oracle, dec_oracle)
        S_oracle[:, i] = np.sum(w_o.conj() * y_m, axis=1)
        # 4. Update Metrics (Shadow Pass)
        m_oracle.update(w_o, y_t, y_i)
        
        # --- B. REAL PATH (Your System) ---
        # 1. Estimated Covariance (Recursive from Classifier)
        R_est = classifier.features.R_smooth
        # 2. Estimated Decisions
        dec_est = est_map[:, i]
        # 3. Compute Weights & Apply
        w_r = actuator.get_weights(y_m, R_est, dec_est)
        S_real[:, i] = np.sum(w_r.conj() * y_m, axis=1)
        # 4. Update Metrics (Shadow Pass)
        m_real.update(w_r, y_t, y_i)

    # --- PHASE 3: REPORTING ---
    op_tgt, op_jam, op_sinr_in, op_sinr_out = m_oracle.report()
    rp_tgt, rp_jam, rp_sinr_in, rp_sinr_out = m_real.report()
    
    print("\n" + "="*65)
    print(f"{' COMPREHENSIVE DIAGNOSTIC REPORT ':^65}")
    print("="*65)
    
    # 1. BRAIN HEALTH
    mask = (oracle_map == 1) | (oracle_map == 5)
    if np.sum(mask) > 0:
        acc = np.mean(est_map[mask] == oracle_map[mask]) * 100
        print(f"1. ESTIMATOR ACCURACY: {acc:.1f}%")
    else:
        print("1. ESTIMATOR ACCURACY: N/A (No active speech)")
    
    # 2. PHYSICS BENCHMARK
    print("-" * 65)
    print(f"{'METRIC':<20} | {'ORACLE (Ideal)':<15} | {'REAL SYSTEM':<15}")
    print("-" * 65)
    print(f"{'Target Preservation':<20} | {op_tgt:>6.2f} dB        | {rp_tgt:>6.2f} dB")
    print(f"{'Jammer Suppression':<20} | {op_jam:>6.2f} dB        | {rp_jam:>6.2f} dB")
    print(f"{'Output SINR':<20} | {op_sinr_out:>6.2f} dB        | {rp_sinr_out:>6.2f} dB")
    print(f"{'Net SINR Gain':<20} | {op_sinr_out-op_sinr_in:>6.2f} dB        | {rp_sinr_out-rp_sinr_in:>6.2f} dB")
    print("-" * 65)
    
    # --- PHASE 4: PLOTTING ---
    print("Generating Plots...")
    t_axis = np.linspace(0, len(audio['mix'])/fs, Y_mix.shape[1])
    f_axis = np.linspace(0, fs/2, Y_mix.shape[0])
    
    fig, ax = plt.subplots(2, 2, figsize=(14, 10))
    
    # Plot 1: Decision Maps
    # 0=Black, 1=Green(Tgt), 2=Red, 3=Yellow, 4=Cyan, 5=Orange(Jam), 6=Magenta(Diff), 7=White(Alias)
    cmap = mcolors.ListedColormap(['black','lime','red','yellow','cyan','orange','magenta','white'])
    
    ax[0,0].imshow(oracle_map, aspect='auto', origin='lower', cmap=cmap, vmin=0, vmax=7)
    ax[0,0].set_title("Ground Truth Map")
    ax[0,0].set_ylabel("Frequency Bin")
    
    ax[0,1].imshow(est_map, aspect='auto', origin='lower', cmap=cmap, vmin=0, vmax=7)
    ax[0,1].set_title(f"Estimator Map (Acc: {acc:.1f}%)")
    
    # Plot 2: Spectrograms
    im1 = ax[1,0].pcolormesh(t_axis, f_axis, 10*np.log10(np.abs(S_oracle)**2 + 1e-12), cmap='inferno', shading='auto')
    ax[1,0].set_title(f"Oracle Output\nSINR: {op_sinr_out:.1f}dB")
    plt.colorbar(im1, ax=ax[1,0])
    
    im2 = ax[1,1].pcolormesh(t_axis, f_axis, 10*np.log10(np.abs(S_real)**2 + 1e-12), cmap='inferno', shading='auto')
    ax[1,1].set_title(f"Real System Output\nSINR: {rp_sinr_out:.1f}dB")
    plt.colorbar(im2, ax=ax[1,1])
    
    plt.tight_layout()
    plt.show()
    
    # Save Audio
    _, wav_o = istft(S_oracle, fs=fs, nperseg=n_fft)
    _, wav_r = istft(S_real, fs=fs, nperseg=n_fft)
    
    # Normalize Output for saving
    def save_wav(name, data):
        mx = np.max(np.abs(data))
        if mx > 0: data = data / mx
        wavfile.write(name, fs, data.astype(np.float32))

    save_wav("diag_oracle.wav", wav_o)
    save_wav("diag_real.wav", wav_r)
    print("Saved 'diag_oracle.wav' and 'diag_real.wav'.")